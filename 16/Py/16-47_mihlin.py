# Михлин Б.С.
'''
16.47 Алгоритм вычисления функции F(n) задан следующими соотношениями:
F(n) = n при n <= 3;
F(n) = F(n - 1) + 2 * F(n // 2)  при чётных n > 3; 
F(n) = F(n - 1) + F(n - 3)  при нечётных n > 3.
Определите количество натуральных значений n, при которых F(n) меньше, чем 10**8.
'''
# Способ 1. Рекурсия.
from functools import *
@lru_cache(None) # запоминает промежуточные результаты (без этой строки программа работает медленно)
def F(n):
    if n <= 3:
        return n
    if n % 2 == 0:
        return F(n - 1) + 2 * F(n // 2)
    return F(n - 1) + F(n - 3)
n = 1
k = 0
while F(n) < 1e8:
    k += 1
    # print(k, n, F(n)) # отладочная
    n += 1
print(k)  # Ответ: 64

# Способ 2. Метод динамического программирования (мемоизации). Здесь:
# f - список (массив), n - индекс списка, 0 - фиктивный элемент (чтобы занять индекс 0).
f = [0, 1, 2, 3]
k = 3
for n in range(4, 10**4):
    if n % 2 == 0:
        f.append(f[n - 1] + 2 * f[n // 2])
        #f += [f[n - 1] + 2 * f[n // 2]] # так чуть короче
    else:
        f.append(f[n - 1] + f[n - 3])
        #f += [f[n - 1] + f[n - 3]]
    if f[-1] < 1e8:
        k += 1
#for n in range(66): # отладочные
    #print(n, f[n])  # строки
print(k)  # Ответ: 64  
